<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Management - Enhanced CSP</title>
    
    <!-- CSS Dependencies -->
    <link rel="stylesheet" href="../css/shared/base.css">
    <link rel="stylesheet" href="../css/shared/components.css">
    <link rel="stylesheet" href="../css/pages/memory.css">
    
    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        /* Memory-specific styles */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .memory-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .memory-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        }

        .memory-card-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .memory-card-icon {
            font-size: 2rem;
        }

        .memory-card-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .memory-stats {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
        }

        .stat-item {
            text-align: center;
            flex: 1;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--text-light);
            margin-top: 0.25rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-light);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 1rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-light));
            transition: width 0.3s ease;
        }

        .data-table {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .table-title {
            font-size: 1.125rem;
            font-weight: 600;
        }

        .table-actions {
            display: flex;
            gap: 0.5rem;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ff5252;
            color: white;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: none;
        }

        .success-message {
            background: #4caf50;
            color: white;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: none;
        }

        .websocket-status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-light);
            border-radius: 20px;
            font-size: 0.875rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff5252;
        }

        .status-indicator.connected {
            background: #4caf50;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <!-- Navigation Sidebar -->
    <nav class="sidebar">
        <div class="sidebar-header">
            <div class="logo">
                <span class="logo-icon">üß†</span>
                <span class="logo-text">Enhanced CSP</span>
            </div>
        </div>

        <ul class="nav-menu">
            <li class="nav-item">
                <a href="index.html" class="nav-link">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Dashboard</span>
                </a>
            </li>
            <li class="nav-item">
                <a href="ai-agents.html" class="nav-link">
                    <span class="nav-icon">ü§ñ</span>
                    <span class="nav-text">AI Agents</span>
                </a>
            </li>
            <li class="nav-item active">
                <a href="memory.html" class="nav-link">
                    <span class="nav-icon">üíæ</span>
                    <span class="nav-text">Memory</span>
                </a>
            </li>
            <li class="nav-item">
                <a href="monitoring.html" class="nav-link">
                    <span class="nav-icon">üìä</span>
                    <span class="nav-text">Monitoring</span>
                </a>
            </li>
            <li class="nav-item">
                <a href="admin.html" class="nav-link">
                    <span class="nav-icon">‚öôÔ∏è</span>
                    <span class="nav-text">Admin</span>
                </a>
            </li>
        </ul>

        <div class="sidebar-footer">
            <div class="memory-status-widget">
                <div style="padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 8px; margin-bottom: 0.5rem;">
                    <div style="font-size: 0.875rem; color: var(--primary); font-weight: 500;">Memory System: <span id="systemStatus">Connecting...</span></div>
                    <div style="font-size: 0.75rem; color: var(--text-light);">Last sync: <span id="lastSync">-</span></div>
                </div>
                <div style="padding: 1rem; background: rgba(37, 99, 235, 0.1); border-radius: 8px;">
                    <div style="font-size: 0.875rem; color: var(--primary); font-weight: 500;">Active Agents: <span id="activeAgentsCount">0</span></div>
                    <div style="font-size: 0.75rem; color: var(--text-light);">Crystals forming: <span id="crystalsFormingCount">0</span></div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content Area -->
    <main class="main-content">
        <div class="content-header">
            <h1 class="content-title">Memory Management Dashboard</h1>
            <div class="header-actions">
                <div class="websocket-status">
                    <span class="status-indicator" id="wsStatusIndicator"></span>
                    <span id="wsStatusText">Disconnected</span>
                </div>
                <button class="btn btn-primary" onclick="memoryManager.showRegisterAgentModal()">
                    <span>‚ûï</span> Register Agent
                </button>
            </div>
        </div>

        <!-- Messages -->
        <div class="error-message" id="errorMessage"></div>
        <div class="success-message" id="successMessage"></div>

        <!-- Tabs Container -->
        <div class="tabs-container">
            <div class="tabs-header">
                <button class="tab-button active" data-tab="working-memory">Working Memory</button>
                <button class="tab-button" data-tab="shared-memory">Shared Memory</button>
                <button class="tab-button" data-tab="crystallized-memory">Crystallized Memory</button>
                <button class="tab-button" data-tab="collective-memory">Collective Memory</button>
                <button class="tab-button" data-tab="memory-analytics">Analytics</button>
                <button class="tab-button" data-tab="memory-optimization">Optimization</button>
                <button class="tab-button" data-tab="memory-sync">Synchronization</button>
                <button class="tab-button" data-tab="memory-settings">Settings</button>
            </div>

            <!-- Working Memory Tab -->
            <div class="tab-content active" id="working-memory">
                <div class="memory-grid">
                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">üí≠</div>
                            <div class="memory-card-title">Working Memory Pool</div>
                        </div>
                        <div class="memory-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="workingMemoryUsed">0</div>
                                <div class="stat-label">Used (MB)</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="workingMemoryTotal">0</div>
                                <div class="stat-label">Total (MB)</div>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="workingMemoryProgress" style="width: 0%;"></div>
                        </div>
                    </div>

                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">üîÑ</div>
                            <div class="memory-card-title">Active Sessions</div>
                        </div>
                        <div class="memory-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="activeSessions">0</div>
                                <div class="stat-label">Sessions</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="activeAgents">0</div>
                                <div class="stat-label">Agents</div>
                            </div>
                        </div>
                    </div>

                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">‚ö°</div>
                            <div class="memory-card-title">Access Speed</div>
                        </div>
                        <div class="memory-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="avgLatency">0ms</div>
                                <div class="stat-label">Avg Latency</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="cacheHitRate">0%</div>
                                <div class="stat-label">Hit Rate</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="data-table">
                    <div class="table-header">
                        <div class="table-title">Active Agents</div>
                        <div class="table-actions">
                            <button class="btn btn-primary" onclick="memoryManager.refreshWorkingMemory()">
                                <span>üîÑ</span> Refresh
                            </button>
                            <button class="btn btn-secondary" onclick="memoryManager.optimizeMemory('working')">
                                <span>‚ö°</span> Optimize
                            </button>
                        </div>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Agent ID</th>
                                <th>Memory Used</th>
                                <th>Capacity</th>
                                <th>Items</th>
                                <th>Cache Size</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="working-memory-table">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Shared Memory Tab -->
            <div class="tab-content" id="shared-memory">
                <div class="memory-grid">
                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">üîó</div>
                            <div class="memory-card-title">Shared Objects</div>
                        </div>
                        <div class="memory-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="sharedObjectsCount">0</div>
                                <div class="stat-label">Total Objects</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="sharedParticipants">0</div>
                                <div class="stat-label">Participants</div>
                            </div>
                        </div>
                    </div>

                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">üîí</div>
                            <div class="memory-card-title">Lock Status</div>
                        </div>
                        <div class="memory-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="lockedObjects">0</div>
                                <div class="stat-label">Locked</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="availableObjects">0</div>
                                <div class="stat-label">Available</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="data-table">
                    <div class="table-header">
                        <div class="table-title">Shared Memory Objects</div>
                        <div class="table-actions">
                            <button class="btn btn-primary" onclick="memoryManager.createSharedObject()">
                                <span>‚ûï</span> Create Object
                            </button>
                            <button class="btn btn-secondary" onclick="memoryManager.refreshSharedMemory()">
                                <span>üîÑ</span> Refresh
                            </button>
                        </div>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Object ID</th>
                                <th>Type</th>
                                <th>Participants</th>
                                <th>Version</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="shared-memory-table">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Crystallized Memory Tab -->
            <div class="tab-content" id="crystallized-memory">
                <div class="memory-grid">
                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">üíé</div>
                            <div class="memory-card-title">Crystal Formation</div>
                        </div>
                        <div class="memory-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="totalCrystals">0</div>
                                <div class="stat-label">Total Crystals</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="formationRate">0/h</div>
                                <div class="stat-label">Formation Rate</div>
                            </div>
                        </div>
                    </div>

                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">‚öóÔ∏è</div>
                            <div class="memory-card-title">Crystal Types</div>
                        </div>
                        <canvas id="crystalTypesChart" style="width: 100%; height: 200px;"></canvas>
                    </div>
                </div>

                <div class="data-table">
                    <div class="table-header">
                        <div class="table-title">Memory Crystals</div>
                        <div class="table-actions">
                            <select id="crystalTypeFilter" onchange="memoryManager.filterCrystals()">
                                <option value="">All Types</option>
                                <option value="KNOWLEDGE">Knowledge</option>
                                <option value="PATTERN">Pattern</option>
                                <option value="SKILL">Skill</option>
                                <option value="EXPERIENCE">Experience</option>
                            </select>
                            <button class="btn btn-secondary" onclick="memoryManager.refreshCrystals()">
                                <span>üîÑ</span> Refresh
                            </button>
                        </div>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Crystal ID</th>
                                <th>Type</th>
                                <th>Participants</th>
                                <th>Strength</th>
                                <th>Formation Count</th>
                                <th>Last Accessed</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="crystallized-memory-table">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Collective Memory Tab -->
            <div class="tab-content" id="collective-memory">
                <div class="memory-grid">
                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">üåê</div>
                            <div class="memory-card-title">Network Insights</div>
                        </div>
                        <div class="memory-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="totalInsights">0</div>
                                <div class="stat-label">Total Insights</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="avgConfidence">0%</div>
                                <div class="stat-label">Avg Confidence</div>
                            </div>
                        </div>
                    </div>

                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">üß©</div>
                            <div class="memory-card-title">Pattern Recognition</div>
                        </div>
                        <div class="memory-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="patternsDetected">0</div>
                                <div class="stat-label">Patterns</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="emergentBehaviors">0</div>
                                <div class="stat-label">Behaviors</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="data-table">
                    <div class="table-header">
                        <div class="table-title">Collective Insights</div>
                        <div class="table-actions">
                            <button class="btn btn-primary" onclick="memoryManager.triggerAnalysis()">
                                <span>üîç</span> Analyze Now
                            </button>
                            <button class="btn btn-secondary" onclick="memoryManager.refreshInsights()">
                                <span>üîÑ</span> Refresh
                            </button>
                        </div>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Insight ID</th>
                                <th>Type</th>
                                <th>Description</th>
                                <th>Confidence</th>
                                <th>Impact Score</th>
                                <th>Contributors</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="collective-memory-table">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Memory Analytics Tab -->
            <div class="tab-content" id="memory-analytics">
                <div class="memory-grid">
                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">üìä</div>
                            <div class="memory-card-title">Memory Usage Trends</div>
                        </div>
                        <canvas id="memoryTrendsChart" style="width: 100%; height: 200px;"></canvas>
                    </div>

                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">‚ö°</div>
                            <div class="memory-card-title">Performance Metrics</div>
                        </div>
                        <div class="memory-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="systemAvailability">99.9%</div>
                                <div class="stat-label">Availability</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="avgResponseTime">0ms</div>
                                <div class="stat-label">Avg Response</div>
                            </div>
                        </div>
                    </div>

                    <div class="memory-card">
                        <div class="memory-card-header">
                            <div class="memory-card-icon">üîÑ</div>
                            <div class="memory-card-title">Synchronization Health</div>
                        </div>
                        <canvas id="syncHealthChart" style="width: 100%; height: 200px;"></canvas>
                    </div>
                </div>
            </div>

            <!-- Other tabs content remains similar but will be connected to API -->
        </div>
    </main>

    <!-- Modals -->
    <div id="registerAgentModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Register New Agent</h2>
            <form id="registerAgentForm">
                <div class="form-group">
                    <label for="agentId">Agent ID:</label>
                    <input type="text" id="agentId" required>
                </div>
                <div class="form-group">
                    <label for="memorySize">Memory Size (MB):</label>
                    <input type="number" id="memorySize" value="256" min="1" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Register</button>
                    <button type="button" class="btn btn-secondary" onclick="memoryManager.closeModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Scripts -->
    <script src="../js/utils/ApiClient.js"></script>
    <script src="../services/authService.js"></script>
    <script src="../services/cspApiService.js"></script>
    
    <script>
        // Memory Management System
        class MemoryManager {
            constructor() {
                this.apiClient = new ApiClient('/api/memory');
                this.ws = null;
                this.charts = {};
                this.refreshInterval = null;
                this.currentTab = 'working-memory';
                
                this.init();
            }

            async init() {
                // Initialize WebSocket connection
                this.connectWebSocket();
                
                // Load initial data
                await this.loadMemoryStats();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Start periodic refresh
                this.startPeriodicRefresh();
                
                // Initialize charts
                this.initializeCharts();
            }

            connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/api/memory/stream`;
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                    this.updateWebSocketStatus(true);
                };

                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleWebSocketMessage(data);
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.updateWebSocketStatus(false);
                };

                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    this.updateWebSocketStatus(false);
                    // Reconnect after 3 seconds
                    setTimeout(() => this.connectWebSocket(), 3000);
                };
            }

            updateWebSocketStatus(connected) {
                const indicator = document.getElementById('wsStatusIndicator');
                const text = document.getElementById('wsStatusText');
                
                if (connected) {
                    indicator.classList.add('connected');
                    text.textContent = 'Connected';
                } else {
                    indicator.classList.remove('connected');
                    text.textContent = 'Disconnected';
                }
            }

            handleWebSocketMessage(data) {
                switch (data.event) {
                    case 'stats_update':
                        this.updateStats(data.stats);
                        break;
                    case 'agent_registered':
                        this.showSuccess(`Agent ${data.agent_id} registered successfully`);
                        this.refreshWorkingMemory();
                        break;
                    case 'interaction_processed':
                        this.updateInteractionStatus(data);
                        break;
                    case 'shared_object_created':
                        this.refreshSharedMemory();
                        break;
                    case 'memory_optimized':
                        this.showSuccess('Memory optimization completed');
                        this.loadMemoryStats();
                        break;
                    default:
                        console.log('Unhandled WebSocket event:', data);
                }
            }

            setupEventListeners() {
                // Tab switching
                document.querySelectorAll('.tab-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        this.switchTab(e.target.getAttribute('data-tab'));
                    });
                });

                // Register agent form
                document.getElementById('registerAgentForm').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    await this.registerAgent();
                });
            }

            switchTab(tabName) {
                // Update active tab
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

                // Update content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName).classList.add('active');

                this.currentTab = tabName;
                
                // Load tab-specific data
                this.loadTabData(tabName);
            }

            async loadTabData(tabName) {
                switch (tabName) {
                    case 'working-memory':
                        await this.refreshWorkingMemory();
                        break;
                    case 'shared-memory':
                        await this.refreshSharedMemory();
                        break;
                    case 'crystallized-memory':
                        await this.refreshCrystals();
                        break;
                    case 'collective-memory':
                        await this.refreshInsights();
                        break;
                    case 'memory-analytics':
                        await this.loadAnalytics();
                        break;
                }
            }

            async loadMemoryStats() {
                try {
                    this.showLoading();
                    const response = await this.apiClient.get('/stats');
                    
                    if (response.success) {
                        this.updateStats(response.stats);
                        this.updateSummary(response.summary);
                    }
                } catch (error) {
                    this.showError('Failed to load memory statistics: ' + error.message);
                } finally {
                    this.hideLoading();
                }
            }

            updateStats(stats) {
                // Update working memory stats
                if (stats.working_memory) {
                    let totalUsed = 0;
                    let totalCapacity = 0;
                    let agentCount = 0;

                    for (const [agentId, agentStats] of Object.entries(stats.working_memory)) {
                        totalUsed += agentStats.used_mb || 0;
                        totalCapacity += agentStats.capacity_mb || 0;
                        agentCount++;
                    }

                    this.updateElement('workingMemoryUsed', totalUsed.toFixed(1));
                    this.updateElement('workingMemoryTotal', totalCapacity.toFixed(1));
                    this.updateElement('activeAgents', agentCount);
                    
                    // Update progress bar
                    const progress = totalCapacity > 0 ? (totalUsed / totalCapacity * 100) : 0;
                    this.updateElement('workingMemoryProgress', null, { style: { width: `${progress}%` } });
                }

                // Update shared memory stats
                if (stats.shared_memory) {
                    this.updateElement('sharedObjectsCount', stats.shared_memory.total_objects || 0);
                    this.updateElement('lockedObjects', stats.shared_memory.locked_objects || 0);
                    this.updateElement('availableObjects', (stats.shared_memory.total_objects || 0) - (stats.shared_memory.locked_objects || 0));
                }

                // Update crystallized memory stats
                if (stats.crystallized_memory) {
                    this.updateElement('totalCrystals', stats.crystallized_memory.total_crystals || 0);
                    this.updateElement('crystalsFormingCount', stats.crystallized_memory.crystals_formed || 0);
                }

                // Update collective memory stats
                if (stats.collective_memory) {
                    this.updateElement('totalInsights', stats.collective_memory.total_insights || 0);
                    this.updateElement('patternsDetected', stats.collective_memory.patterns_detected || 0);
                }
            }

            updateSummary(summary) {
                if (summary) {
                    this.updateElement('activeAgentsCount', summary.active_agents || 0);
                    this.updateElement('systemStatus', 'Online');
                    this.updateElement('lastSync', new Date().toLocaleTimeString());
                }
            }

            async refreshWorkingMemory() {
                try {
                    const response = await this.apiClient.get('/stats?layer=working_memory');
                    if (response.success && response.stats) {
                        const tbody = document.getElementById('working-memory-table');
                        tbody.innerHTML = '';

                        for (const [agentId, stats] of Object.entries(response.stats)) {
                            const row = tbody.insertRow();
                            row.innerHTML = `
                                <td>${agentId}</td>
                                <td>${stats.used_mb.toFixed(2)} MB</td>
                                <td>${stats.capacity_mb.toFixed(2)} MB</td>
                                <td>${stats.item_count}</td>
                                <td>${stats.cache_size}</td>
                                <td>
                                    <button class="btn btn-sm btn-warning" onclick="memoryManager.viewAgentDetails('${agentId}')">View</button>
                                    <button class="btn btn-sm btn-danger" onclick="memoryManager.clearAgentMemory('${agentId}')">Clear</button>
                                </td>
                            `;
                        }
                    }
                } catch (error) {
                    this.showError('Failed to refresh working memory: ' + error.message);
                }
            }

            async refreshSharedMemory() {
                try {
                    const response = await this.apiClient.get('/shared/list');
                    if (response.success) {
                        const tbody = document.getElementById('shared-memory-table');
                        tbody.innerHTML = '';

                        response.objects.forEach(obj => {
                            const row = tbody.insertRow();
                            row.innerHTML = `
                                <td>${obj.id}</td>
                                <td>${obj.type}</td>
                                <td>${obj.participants.join(', ')}</td>
                                <td>${obj.version}</td>
                                <td>${obj.locked ? 'üîí Locked' : '‚úÖ Available'}</td>
                                <td>
                                    <button class="btn btn-sm btn-primary" onclick="memoryManager.viewSharedObject('${obj.id}')">View</button>
                                </td>
                            `;
                        });
                    }
                } catch (error) {
                    this.showError('Failed to refresh shared memory: ' + error.message);
                }
            }

            async refreshCrystals() {
                try {
                    const filter = document.getElementById('crystalTypeFilter').value;
                    const url = filter ? `/crystallized/list?crystal_type=${filter}` : '/crystallized/list';
                    
                    const response = await this.apiClient.get(url);
                    if (response.success) {
                        const tbody = document.getElementById('crystallized-memory-table');
                        tbody.innerHTML = '';

                        response.crystals.forEach(crystal => {
                            const row = tbody.insertRow();
                            row.innerHTML = `
                                <td>${crystal.id}</td>
                                <td>${crystal.type}</td>
                                <td>${crystal.participants.join(', ')}</td>
                                <td>${(crystal.strength * 100).toFixed(1)}%</td>
                                <td>${crystal.formation_count}</td>
                                <td>${new Date(crystal.last_accessed).toLocaleString()}</td>
                                <td>
                                    <button class="btn btn-sm btn-primary" onclick="memoryManager.viewCrystal('${crystal.id}')">View</button>
                                </td>
                            `;
                        });
                        
                        // Update crystal types chart
                        this.updateCrystalTypesChart(response.crystals);
                    }
                } catch (error) {
                    this.showError('Failed to refresh crystals: ' + error.message);
                }
            }

            async refreshInsights() {
                try {
                    const response = await this.apiClient.get('/collective/insights');
                    if (response.success) {
                        const tbody = document.getElementById('collective-memory-table');
                        tbody.innerHTML = '';

                        response.insights.forEach(insight => {
                            const row = tbody.insertRow();
                            row.innerHTML = `
                                <td>${insight.id}</td>
                                <td>${insight.type}</td>
                                <td>${insight.description}</td>
                                <td>${(insight.confidence * 100).toFixed(1)}%</td>
                                <td>${insight.impact_score.toFixed(2)}</td>
                                <td>${insight.contributors.length} agents</td>
                                <td>
                                    <button class="btn btn-sm btn-success" onclick="memoryManager.exploreInsight('${insight.id}')">Explore</button>
                                </td>
                            `;
                        });
                    }
                } catch (error) {
                    this.showError('Failed to refresh insights: ' + error.message);
                }
            }

            async registerAgent() {
                const agentId = document.getElementById('agentId').value;
                const memorySize = parseInt(document.getElementById('memorySize').value);

                try {
                    this.showLoading();
                    const response = await this.apiClient.post('/register-agent', {
                        agent_id: agentId,
                        working_memory_mb: memorySize
                    });

                    if (response.success) {
                        this.showSuccess(`Agent ${agentId} registered successfully`);
                        this.closeModal();
                        await this.refreshWorkingMemory();
                    } else {
                        this.showError(response.error || 'Failed to register agent');
                    }
                } catch (error) {
                    this.showError('Failed to register agent: ' + error.message);
                } finally {
                    this.hideLoading();
                }
            }

            async clearAgentMemory(agentId) {
                if (!confirm(`Clear all memory for agent ${agentId}?`)) return;

                try {
                    const response = await this.apiClient.delete(`/working/${agentId}/clear`);
                    if (response.success) {
                        this.showSuccess(`Memory cleared for agent ${agentId}`);
                        await this.refreshWorkingMemory();
                    }
                } catch (error) {
                    this.showError('Failed to clear memory: ' + error.message);
                }
            }

            async optimizeMemory(layer) {
                try {
                    this.showLoading();
                    const response = await this.apiClient.post(`/optimize${layer ? `?layer=${layer}` : ''}`);
                    
                    if (response.success) {
                        this.showSuccess('Memory optimization started');
                    }
                } catch (error) {
                    this.showError('Failed to optimize memory: ' + error.message);
                } finally {
                    this.hideLoading();
                }
            }

            async triggerAnalysis() {
                try {
                    const response = await this.apiClient.post('/collective/analyze');
                    if (response.success) {
                        this.showSuccess('Collective analysis scheduled');
                    } else {
                        this.showError(response.error || 'Failed to trigger analysis');
                    }
                } catch (error) {
                    this.showError('Failed to trigger analysis: ' + error.message);
                }
            }

            initializeCharts() {
                // Memory Trends Chart
                const trendsCtx = document.getElementById('memoryTrendsChart');
                if (trendsCtx) {
                    this.charts.trends = new Chart(trendsCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Working Memory',
                                data: [],
                                borderColor: '#3b82f6',
                                tension: 0.1
                            }, {
                                label: 'Shared Objects',
                                data: [],
                                borderColor: '#10b981',
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false
                        }
                    });
                }

                // Crystal Types Chart
                const crystalCtx = document.getElementById('crystalTypesChart');
                if (crystalCtx) {
                    this.charts.crystalTypes = new Chart(crystalCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Knowledge', 'Pattern', 'Skill', 'Experience'],
                            datasets: [{
                                data: [0, 0, 0, 0],
                                backgroundColor: ['#3b82f6', '#10b981', '#f59e0b', '#ef4444']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false
                        }
                    });
                }

                // Sync Health Chart
                const syncCtx = document.getElementById('syncHealthChart');
                if (syncCtx) {
                    this.charts.syncHealth = new Chart(syncCtx, {
                        type: 'bar',
                        data: {
                            labels: ['Success', 'Conflicts', 'Failures'],
                            datasets: [{
                                label: 'Sync Operations',
                                data: [0, 0, 0],
                                backgroundColor: ['#10b981', '#f59e0b', '#ef4444']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false
                        }
                    });
                }
            }

            updateCrystalTypesChart(crystals) {
                if (!this.charts.crystalTypes) return;

                const typeCounts = { KNOWLEDGE: 0, PATTERN: 0, SKILL: 0, EXPERIENCE: 0 };
                crystals.forEach(crystal => {
                    if (typeCounts.hasOwnProperty(crystal.type)) {
                        typeCounts[crystal.type]++;
                    }
                });

                this.charts.crystalTypes.data.datasets[0].data = Object.values(typeCounts);
                this.charts.crystalTypes.update();
            }

            startPeriodicRefresh() {
                // Refresh every 30 seconds
                this.refreshInterval = setInterval(() => {
                    this.loadMemoryStats();
                }, 30000);
            }

            // Modal Management
            showRegisterAgentModal() {
                document.getElementById('registerAgentModal').style.display = 'block';
            }

            closeModal() {
                document.getElementById('registerAgentModal').style.display = 'none';
                document.getElementById('registerAgentForm').reset();
            }

            // Utility Functions
            updateElement(id, text, attributes) {
                const element = document.getElementById(id);
                if (element) {
                    if (text !== null) element.textContent = text;
                    if (attributes) {
                        Object.entries(attributes).forEach(([key, value]) => {
                            if (key === 'style') {
                                Object.assign(element.style, value);
                            } else {
                                element.setAttribute(key, value);
                            }
                        });
                    }
                }
            }

            showLoading() {
                document.getElementById('loadingOverlay').style.display = 'flex';
            }

            hideLoading() {
                document.getElementById('loadingOverlay').style.display = 'none';
            }

            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }

            showSuccess(message) {
                const successDiv = document.getElementById('successMessage');
                successDiv.textContent = message;
                successDiv.style.display = 'block';
                setTimeout(() => {
                    successDiv.style.display = 'none';
                }, 3000);
            }

            // View Details Functions
            async viewAgentDetails(agentId) {
                // Implementation for viewing agent details
                console.log('View agent details:', agentId);
            }

            async viewSharedObject(objectId) {
                // Implementation for viewing shared object
                console.log('View shared object:', objectId);
            }

            async viewCrystal(crystalId) {
                try {
                    const response = await this.apiClient.get(`/crystallized/${crystalId}`);
                    if (response.success) {
                        // Show crystal details in a modal or panel
                        console.log('Crystal details:', response.crystal);
                    }
                } catch (error) {
                    this.showError('Failed to load crystal details: ' + error.message);
                }
            }

            async exploreInsight(insightId) {
                // Implementation for exploring insight
                console.log('Explore insight:', insightId);
            }

            // Cleanup
            destroy() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
                if (this.ws) {
                    this.ws.close();
                }
            }
        }

        // Initialize Memory Manager
        const memoryManager = new MemoryManager();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            memoryManager.destroy();
        });
    </script>
</body>
</html>