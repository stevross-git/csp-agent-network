<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Quantum CSP Visual Designer - Next-Gen AI Process Builder</title>
    <style>
        :root {
            --primary-glow: #00ff88;
            --secondary-glow: #00ccff;
            --accent-glow: #ff6b6b;
            --warning-glow: #ffd93d;
            --bg-dark: #0a0a0f;
            --bg-darker: #050508;
            --surface: rgba(255, 255, 255, 0.05);
            --surface-hover: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #888888;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, sans-serif;
            background: radial-gradient(ellipse at center, var(--bg-dark) 0%, var(--bg-darker) 100%);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated background particles */
        .bg-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--primary-glow);
            border-radius: 50%;
            opacity: 0.3;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% { transform: translateY(100vh) translateX(0); opacity: 0; }
            10% { opacity: 0.3; }
            90% { opacity: 0.3; }
            100% { transform: translateY(-10vh) translateX(100px); opacity: 0; }
        }

        /* Header with glassmorphism */
        .header {
            position: relative;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 32px rgba(0, 0, 0, 0.5);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo h1 {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(45deg, var(--primary-glow), var(--secondary-glow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        .quantum-indicator {
            width: 60px;
            height: 60px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .quantum-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-top: 2px solid var(--primary-glow);
            border-radius: 50%;
            animation: quantum-spin 3s linear infinite;
        }

        .quantum-ring:nth-child(2) {
            animation-duration: 2s;
            animation-direction: reverse;
            border-top-color: var(--secondary-glow);
        }

        .quantum-core {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, var(--primary-glow), transparent);
            border-radius: 50%;
            box-shadow: 0 0 20px var(--primary-glow);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes quantum-spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--surface);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--primary-glow);
            border-radius: 50%;
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        /* Main layout */
        .main-container {
            position: relative;
            z-index: 1;
            display: grid;
            grid-template-columns: 320px 1fr 380px;
            height: calc(100vh - 80px);
            gap: 1px;
            background: rgba(0, 255, 136, 0.1);
        }

        /* Left sidebar */
        .left-panel {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(0, 255, 136, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 1.5rem;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            background: var(--surface);
        }

        .panel-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary-glow);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-subtitle {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Component palette */
        .component-palette {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-glow) transparent;
        }

        .component-category {
            margin-bottom: 2rem;
        }

        .category-header {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--secondary-glow);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .component-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }

        .component-item {
            background: var(--surface);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1rem;
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .component-item:hover {
            background: var(--surface-hover);
            border-color: var(--primary-glow);
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.2);
        }

        .component-item:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        .component-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        .component-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            line-height: 1.2;
        }

        /* Canvas area */
        .canvas-container {
            background: var(--bg-darker);
            position: relative;
            overflow: hidden;
        }

        .canvas {
            width: 100%;
            height: 100%;
            position: relative;
            background-image: 
                radial-gradient(circle at 20px 20px, rgba(0, 255, 136, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
            background-position: 0 0, 20px 20px;
        }

        .canvas-toolbar {
            position: absolute;
            top: 1rem;
            left: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 100;
        }

        .canvas-tools {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            z-index: 100;
        }

        .tool-btn {
            width: 48px;
            height: 48px;
            background: var(--surface);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(20px);
            color: var(--text-secondary);
            font-size: 1.2rem;
        }

        .tool-btn:hover, .tool-btn.active {
            background: var(--primary-glow);
            color: var(--bg-dark);
            border-color: var(--primary-glow);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }

        /* Nodes */
        .canvas-node {
            position: absolute;
            min-width: 120px;
            min-height: 80px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 16px;
            padding: 1rem;
            cursor: move;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            user-select: none;
        }

        .canvas-node:hover {
            border-color: var(--primary-glow);
            box-shadow: 0 12px 48px rgba(0, 255, 136, 0.3);
            transform: translateY(-2px);
        }

        .canvas-node.selected {
            border-color: var(--accent-glow);
            box-shadow: 0 0 32px rgba(255, 107, 107, 0.4);
        }

        .canvas-node.ai-enhanced {
            border-color: var(--secondary-glow);
            background: rgba(0, 204, 255, 0.05);
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .node-type {
            font-size: 1.5rem;
        }

        .node-menu {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--surface);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .node-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--primary-glow);
            margin-bottom: 0.5rem;
        }

        .node-description {
            font-size: 0.75rem;
            color: var(--text-muted);
            line-height: 1.3;
        }

        .node-status {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 16px;
            height: 16px;
            background: var(--primary-glow);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        /* Connection ports */
        .connection-port {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--secondary-glow);
            border-radius: 50%;
            border: 2px solid var(--bg-dark);
            cursor: crosshair;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .canvas-node:hover .connection-port {
            opacity: 1;
        }

        .connection-port.input {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-port.output {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-port:hover {
            transform: scale(1.3) translateY(-50%);
            box-shadow: 0 0 15px var(--secondary-glow);
        }

        /* Connection lines */
        .connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        .connection-path {
            fill: none;
            stroke: var(--primary-glow);
            stroke-width: 3;
            filter: drop-shadow(0 0 6px rgba(0, 255, 136, 0.6));
            animation: flow 3s ease-in-out infinite;
        }

        @keyframes flow {
            0%, 100% { stroke-dasharray: 8 4; stroke-dashoffset: 0; }
            50% { stroke-dashoffset: 12; }
        }

        /* Right panel */
        .right-panel {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(0, 255, 136, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .properties-panel {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .property-section {
            margin-bottom: 2rem;
            background: var(--surface);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.5rem;
        }

        .property-section-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--secondary-glow);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .property-field {
            margin-bottom: 1rem;
        }

        .property-label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .property-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.75rem;
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .property-input:focus {
            outline: none;
            border-color: var(--primary-glow);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .property-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary-glow);
        }

        .toggle-handle {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle-switch.active .toggle-handle {
            transform: translateX(20px);
        }

        /* AI Panel */
        .ai-panel {
            background: rgba(0, 204, 255, 0.05);
            border-top: 1px solid rgba(0, 204, 255, 0.3);
            padding: 1.5rem;
        }

        .ai-suggestions {
            margin-bottom: 1rem;
        }

        .suggestion-item {
            background: var(--surface);
            border: 1px solid rgba(0, 204, 255, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .suggestion-item:hover {
            background: var(--surface-hover);
            border-color: var(--secondary-glow);
        }

        .suggestion-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--secondary-glow);
            margin-bottom: 0.25rem;
        }

        .suggestion-description {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* Action buttons */
        .btn {
            background: var(--surface);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
        }

        .btn:hover {
            background: var(--surface-hover);
            transform: translateY(-1px);
        }

        .btn-primary {
            background: var(--primary-glow);
            color: var(--bg-dark);
            border-color: var(--primary-glow);
        }

        .btn-primary:hover {
            background: #00dd77;
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
        }

        .btn-secondary {
            background: var(--secondary-glow);
            color: var(--bg-dark);
            border-color: var(--secondary-glow);
        }

        .btn-secondary:hover {
            background: #00bbee;
            box-shadow: 0 4px 20px rgba(0, 204, 255, 0.3);
        }

        /* Code preview */
        .code-preview {
            background: var(--bg-darker);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.8rem;
            color: var(--primary-glow);
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 1rem;
        }

        /* Floating action menu */
        .fab-menu {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 1000;
        }

        .fab-button {
            width: 56px;
            height: 56px;
            background: var(--primary-glow);
            border-radius: 50%;
            border: none;
            color: var(--bg-dark);
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.4);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fab-button:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 48px rgba(0, 255, 136, 0.6);
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 280px 1fr 320px;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
            }
            
            .left-panel, .right-panel {
                height: 200px;
            }
        }

        /* Loading and animations */
        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide-in-left {
            animation: slideInLeft 0.8s ease-out;
        }

        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .slide-in-right {
            animation: slideInRight 0.8s ease-out;
        }

        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 136, 0.5);
        }
    </style>
</head>
<body>
    <!-- Animated background -->
    <div class="bg-particles" id="particles"></div>

    <!-- Header -->
    <header class="header">
        <div class="logo">
            <div class="quantum-indicator">
                <div class="quantum-ring"></div>
                <div class="quantum-ring"></div>
                <div class="quantum-core"></div>
            </div>
            <h1>Quantum CSP Designer</h1>
        </div>
        
        <div class="header-controls">
            <div class="ai-status">
                <div class="status-dot"></div>
                <span>AI Orchestrator Active</span>
            </div>
            <button class="btn btn-secondary" onclick="exportDesign()">
                üì§ Export
            </button>
            <button class="btn btn-primary" onclick="runSimulation()">
                ‚ñ∂Ô∏è Execute
            </button>
        </div>
    </header>

    <!-- Main container -->
    <div class="main-container">
        <!-- Left panel -->
        <div class="left-panel slide-in-left">
            <div class="panel-header">
                <div class="panel-title">
                    üß© Process Library
                </div>
                <div class="panel-subtitle">
                    Drag components to build your CSP network
                </div>
            </div>
            
            <div class="component-palette">
                <!-- AI Processes -->
                <div class="component-category">
                    <div class="category-header">AI Processes</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="ai-agent">
                            <div class="component-icon">ü§ñ</div>
                            <div class="component-name">AI Agent</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="llm-processor">
                            <div class="component-icon">üß†</div>
                            <div class="component-name">LLM Processor</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="reasoning-coordinator">
                            <div class="component-icon">üéØ</div>
                            <div class="component-name">Reasoning Hub</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="memory-manager">
                            <div class="component-icon">üíæ</div>
                            <div class="component-name">Memory Bank</div>
                        </div>
                    </div>
                </div>

                <!-- Core CSP -->
                <div class="component-category">
                    <div class="category-header">Core CSP</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="atomic">
                            <div class="component-icon">‚öõÔ∏è</div>
                            <div class="component-name">Atomic Process</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="composite">
                            <div class="component-icon">üîß</div>
                            <div class="component-name">Composite</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="channel">
                            <div class="component-icon">üì°</div>
                            <div class="component-name">Channel</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="guard">
                            <div class="component-icon">üõ°Ô∏è</div>
                            <div class="component-name">Guard</div>
                        </div>
                    </div>
                </div>

                <!-- Communication -->
                <div class="component-category">
                    <div class="category-header">Communication</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="message-queue">
                            <div class="component-icon">üì¨</div>
                            <div class="component-name">Message Queue</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="protocol-handler">
                            <div class="component-icon">üåê</div>
                            <div class="component-name">Protocol Handler</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="event-bus">
                            <div class="component-icon">üöå</div>
                            <div class="component-name">Event Bus</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="sync-barrier">
                            <div class="component-icon">üöß</div>
                            <div class="component-name">Sync Barrier</div>
                        </div>
                    </div>
                </div>

                <!-- Data Processing -->
                <div class="component-category">
                    <div class="category-header">Data Processing</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="data-transformer">
                            <div class="component-icon">üîÑ</div>
                            <div class="component-name">Data Transformer</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="stream-processor">
                            <div class="component-icon">üåä</div>
                            <div class="component-name">Stream Processor</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="aggregator">
                            <div class="component-icon">üìä</div>
                            <div class="component-name">Data Aggregator</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="filter">
                            <div class="component-icon">üîç</div>
                            <div class="component-name">Data Filter</div>
                        </div>
                    </div>
                </div>

                <!-- Security & Auth -->
                <div class="component-category">
                    <div class="category-header">Security</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="auth-gateway">
                            <div class="component-icon">üîê</div>
                            <div class="component-name">Auth Gateway</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="encryption-node">
                            <div class="component-icon">üõ°Ô∏è</div>
                            <div class="component-name">Encryption Node</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="validator">
                            <div class="component-icon">‚úÖ</div>
                            <div class="component-name">Input Validator</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="rate-limiter">
                            <div class="component-icon">‚è±Ô∏è</div>
                            <div class="component-name">Rate Limiter</div>
                        </div>
                    </div>
                </div>

                <!-- Monitoring -->
                <div class="component-category">
                    <div class="category-header">Monitoring</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="health-checker">
                            <div class="component-icon">üíì</div>
                            <div class="component-name">Health Monitor</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="metrics-collector">
                            <div class="component-icon">üìà</div>
                            <div class="component-name">Metrics Collector</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="logger">
                            <div class="component-icon">üìù</div>
                            <div class="component-name">Event Logger</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="alerter">
                            <div class="component-icon">üö®</div>
                            <div class="component-name">Alert Manager</div>
                        </div>
                    </div>
                </div>

                <!-- External Integration -->
                <div class="component-category">
                    <div class="category-header">Integration</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="api-connector">
                            <div class="component-icon">üîå</div>
                            <div class="component-name">API Connector</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="database-adapter">
                            <div class="component-icon">üóÑÔ∏è</div>
                            <div class="component-name">Database Adapter</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="webhook-handler">
                            <div class="component-icon">ü™ù</div>
                            <div class="component-name">Webhook Handler</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="file-processor">
                            <div class="component-icon">üìÅ</div>
                            <div class="component-name">File Processor</div>
                        </div>
                    </div>
                </div>

                <!-- Advanced AI -->
                <div class="component-category">
                    <div class="category-header">Advanced AI</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="neural-network">
                            <div class="component-icon">üß¨</div>
                            <div class="component-name">Neural Network</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="decision-tree">
                            <div class="component-icon">üå≥</div>
                            <div class="component-name">Decision Tree</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="pattern-matcher">
                            <div class="component-icon">üéØ</div>
                            <div class="component-name">Pattern Matcher</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="ml-pipeline">
                            <div class="component-icon">üöÄ</div>
                            <div class="component-name">ML Pipeline</div>
                        </div>
                    </div>
                </div>

                <!-- Workflow -->
                <div class="component-category">
                    <div class="category-header">Workflow</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="scheduler">
                            <div class="component-icon">‚è∞</div>
                            <div class="component-name">Task Scheduler</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="condition-router">
                            <div class="component-icon">üõ§Ô∏è</div>
                            <div class="component-name">Condition Router</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="loop-controller">
                            <div class="component-icon">üîÑ</div>
                            <div class="component-name">Loop Controller</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="parallel-executor">
                            <div class="component-icon">‚ö°</div>
                            <div class="component-name">Parallel Executor</div>
                        </div>
                    </div>
                </div>

                <!-- Storage -->
                <div class="component-category">
                    <div class="category-header">Storage</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="cache-manager">
                            <div class="component-icon">üè™</div>
                            <div class="component-name">Cache Manager</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="state-store">
                            <div class="component-icon">üíΩ</div>
                            <div class="component-name">State Store</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="blob-storage">
                            <div class="component-icon">üóÉÔ∏è</div>
                            <div class="component-name">Blob Storage</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="search-index">
                            <div class="component-icon">üîé</div>
                            <div class="component-name">Search Index</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas area -->
        <div class="canvas-container">
            <div class="canvas" id="canvas">
                <div class="canvas-toolbar">
                    <div class="tool-btn active" data-tool="select" title="Select Tool">
                        üñ±Ô∏è
                    </div>
                    <div class="tool-btn" data-tool="connect" title="Connect Tool">
                        üîó
                    </div>
                    <div class="tool-btn" data-tool="move" title="Move Tool">
                        ‚úã
                    </div>
                </div>
                
                <div class="canvas-tools">
                    <div class="tool-btn" onclick="zoomIn()" title="Zoom In">
                        üîç+
                    </div>
                    <div class="tool-btn" onclick="resetZoom()" title="Reset Zoom">
                        üéØ
                    </div>
                    <div class="tool-btn" onclick="zoomOut()" title="Zoom Out">
                        üîç-
                    </div>
                    <div class="tool-btn" onclick="autoLayout()" title="Auto Layout">
                        üìê
                    </div>
                    <div class="tool-btn" onclick="clearCanvas()" title="Clear All">
                        üóëÔ∏è
                    </div>
                </div>
                
                <!-- SVG for connections -->
                <svg id="connections-svg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50;">
                </svg>
            </div>
        </div>

        <!-- Right panel -->
        <div class="right-panel slide-in-right">
            <div class="panel-header">
                <div class="panel-title">
                    ‚öôÔ∏è Properties
                </div>
                <div class="panel-subtitle">
                    Configure selected components
                </div>
            </div>
            
            <div class="properties-panel" id="properties-panel">
                <div class="property-section">
                    <div class="property-section-title">
                        üìä Selection Info
                    </div>
                    <div id="selection-info">
                        <p style="color: var(--text-muted); font-style: italic;">
                            Select a component to view its properties
                        </p>
                    </div>
                </div>

                <div class="property-section">
                    <div class="property-section-title">
                        üéõÔ∏è Canvas Settings
                    </div>
                    <div class="property-field">
                        <label class="property-label">Grid Size</label>
                        <input type="range" class="property-input" min="20" max="100" value="40" id="grid-size">
                    </div>
                    <div class="property-field">
                        <div class="property-toggle" onclick="toggleGrid()">
                            <div class="toggle-switch active" id="grid-toggle">
                                <div class="toggle-handle"></div>
                            </div>
                            <span>Show Grid</span>
                        </div>
                    </div>
                    <div class="property-field">
                        <div class="property-toggle" onclick="toggleSnapToGrid()">
                            <div class="toggle-switch" id="snap-toggle">
                                <div class="toggle-handle"></div>
                            </div>
                            <span>Snap to Grid</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="ai-panel">
                <div class="property-section-title">
                    ü§ñ AI Assistance
                </div>
                <div class="ai-suggestions">
                    <div class="suggestion-item" onclick="applySuggestion('optimize')">
                        <div class="suggestion-title">Optimize Network</div>
                        <div class="suggestion-description">Add caching and load balancing components</div>
                    </div>
                    <div class="suggestion-item" onclick="applySuggestion('validate')">
                        <div class="suggestion-title">Security Review</div>
                        <div class="suggestion-description">Add authentication and encryption layers</div>
                    </div>
                    <div class="suggestion-item" onclick="applySuggestion('generate')">
                        <div class="suggestion-title">Add Monitoring</div>
                        <div class="suggestion-description">Include health checks and metrics collection</div>
                    </div>
                    <div class="suggestion-item" onclick="applySuggestion('ml-enhance')">
                        <div class="suggestion-title">ML Enhancement</div>
                        <div class="suggestion-description">Integrate neural networks and pattern matching</div>
                    </div>
                </div>
                
                <button class="btn btn-primary" onclick="analyzeWithAI()" style="width: 100%;">
                    üß† Deep Analysis
                </button>
            </div>
        </div>
    </div>

    <!-- Floating action button -->
    <div class="fab-menu">
        <button class="fab-button" onclick="openQuickActions()" title="Quick Actions">
            ‚ö°
        </button>
    </div>

    <script>
        // Global state
        let currentTool = 'select';
        let selectedNodes = new Set();
        let connections = [];
        let nodes = [];
        let nodeCounter = 0;
        let isConnecting = false;
        let connectionStart = null;
        let zoomLevel = 1;
        let panOffset = { x: 0, y: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let canvasSettings = {
            gridSize: 40,
            showGrid: true,
            snapToGrid: false
        };

        // Component templates
        const componentTemplates = {
            // AI Processes
            'ai-agent': {
                icon: 'ü§ñ',
                title: 'AI Agent',
                description: 'Intelligent autonomous process',
                color: '#00ff88',
                ports: { inputs: 2, outputs: 2 }
            },
            'llm-processor': {
                icon: 'üß†',
                title: 'LLM Processor',
                description: 'Large language model interface',
                color: '#00ccff',
                ports: { inputs: 1, outputs: 1 }
            },
            'reasoning-coordinator': {
                icon: 'üéØ',
                title: 'Reasoning Hub',
                description: 'Multi-agent coordination center',
                color: '#ff6b6b',
                ports: { inputs: 3, outputs: 3 }
            },
            'memory-manager': {
                icon: 'üíæ',
                title: 'Memory Bank',
                description: 'Persistent memory storage',
                color: '#e74c3c',
                ports: { inputs: 2, outputs: 2 }
            },

            // Core CSP
            'atomic': {
                icon: '‚öõÔ∏è',
                title: 'Atomic Process',
                description: 'Basic process unit',
                color: '#ffd93d',
                ports: { inputs: 1, outputs: 1 }
            },
            'composite': {
                icon: 'üîß',
                title: 'Composite Process',
                description: 'Container for sub-processes',
                color: '#f39c12',
                ports: { inputs: 2, outputs: 2 }
            },
            'channel': {
                icon: 'üì°',
                title: 'Communication Channel',
                description: 'Message passing interface',
                color: '#9b59b6',
                ports: { inputs: 0, outputs: 0 }
            },
            'guard': {
                icon: 'üõ°Ô∏è',
                title: 'Guard Process',
                description: 'Conditional execution control',
                color: '#95a5a6',
                ports: { inputs: 1, outputs: 2 }
            },

            // Communication
            'message-queue': {
                icon: 'üì¨',
                title: 'Message Queue',
                description: 'Asynchronous message buffer',
                color: '#3498db',
                ports: { inputs: 1, outputs: 1 }
            },
            'protocol-handler': {
                icon: 'üåê',
                title: 'Protocol Handler',
                description: 'Network protocol processor',
                color: '#2ecc71',
                ports: { inputs: 1, outputs: 1 }
            },
            'event-bus': {
                icon: 'üöå',
                title: 'Event Bus',
                description: 'Distributed event system',
                color: '#e67e22',
                ports: { inputs: 3, outputs: 3 }
            },
            'sync-barrier': {
                icon: 'üöß',
                title: 'Sync Barrier',
                description: 'Process synchronization point',
                color: '#f1c40f',
                ports: { inputs: 2, outputs: 1 }
            },

            // Data Processing
            'data-transformer': {
                icon: 'üîÑ',
                title: 'Data Transformer',
                description: 'Transform data between formats',
                color: '#1abc9c',
                ports: { inputs: 1, outputs: 1 }
            },
            'stream-processor': {
                icon: 'üåä',
                title: 'Stream Processor',
                description: 'Real-time data stream handler',
                color: '#16a085',
                ports: { inputs: 1, outputs: 1 }
            },
            'aggregator': {
                icon: 'üìä',
                title: 'Data Aggregator',
                description: 'Combine multiple data sources',
                color: '#2980b9',
                ports: { inputs: 3, outputs: 1 }
            },
            'filter': {
                icon: 'üîç',
                title: 'Data Filter',
                description: 'Filter data based on criteria',
                color: '#8e44ad',
                ports: { inputs: 1, outputs: 1 }
            },

            // Security & Auth
            'auth-gateway': {
                icon: 'üîê',
                title: 'Auth Gateway',
                description: 'Authentication and authorization',
                color: '#c0392b',
                ports: { inputs: 1, outputs: 2 }
            },
            'encryption-node': {
                icon: 'üõ°Ô∏è',
                title: 'Encryption Node',
                description: 'Data encryption/decryption',
                color: '#a93226',
                ports: { inputs: 1, outputs: 1 }
            },
            'validator': {
                icon: '‚úÖ',
                title: 'Input Validator',
                description: 'Validate input data integrity',
                color: '#27ae60',
                ports: { inputs: 1, outputs: 2 }
            },
            'rate-limiter': {
                icon: '‚è±Ô∏è',
                title: 'Rate Limiter',
                description: 'Control request frequency',
                color: '#d35400',
                ports: { inputs: 1, outputs: 1 }
            },

            // Monitoring
            'health-checker': {
                icon: 'üíì',
                title: 'Health Monitor',
                description: 'System health monitoring',
                color: '#e91e63',
                ports: { inputs: 1, outputs: 1 }
            },
            'metrics-collector': {
                icon: 'üìà',
                title: 'Metrics Collector',
                description: 'Collect performance metrics',
                color: '#673ab7',
                ports: { inputs: 2, outputs: 1 }
            },
            'logger': {
                icon: 'üìù',
                title: 'Event Logger',
                description: 'Log system events',
                color: '#607d8b',
                ports: { inputs: 1, outputs: 0 }
            },
            'alerter': {
                icon: 'üö®',
                title: 'Alert Manager',
                description: 'Send system alerts',
                color: '#ff5722',
                ports: { inputs: 1, outputs: 0 }
            },

            // External Integration
            'api-connector': {
                icon: 'üîå',
                title: 'API Connector',
                description: 'Connect to external APIs',
                color: '#4caf50',
                ports: { inputs: 1, outputs: 1 }
            },
            'database-adapter': {
                icon: 'üóÑÔ∏è',
                title: 'Database Adapter',
                description: 'Database connection interface',
                color: '#795548',
                ports: { inputs: 1, outputs: 1 }
            },
            'webhook-handler': {
                icon: 'ü™ù',
                title: 'Webhook Handler',
                description: 'Process incoming webhooks',
                color: '#009688',
                ports: { inputs: 0, outputs: 1 }
            },
            'file-processor': {
                icon: 'üìÅ',
                title: 'File Processor',
                description: 'Process file operations',
                color: '#ff9800',
                ports: { inputs: 1, outputs: 1 }
            },

            // Advanced AI
            'neural-network': {
                icon: 'üß¨',
                title: 'Neural Network',
                description: 'Deep learning neural network',
                color: '#e1bee7',
                ports: { inputs: 1, outputs: 1 }
            },
            'decision-tree': {
                icon: 'üå≥',
                title: 'Decision Tree',
                description: 'Decision-making algorithm',
                color: '#a5d6a7',
                ports: { inputs: 1, outputs: 2 }
            },
            'pattern-matcher': {
                icon: 'üéØ',
                title: 'Pattern Matcher',
                description: 'Pattern recognition engine',
                color: '#ffccbc',
                ports: { inputs: 1, outputs: 1 }
            },
            'ml-pipeline': {
                icon: 'üöÄ',
                title: 'ML Pipeline',
                description: 'Machine learning workflow',
                color: '#b39ddb',
                ports: { inputs: 2, outputs: 1 }
            },

            // Workflow
            'scheduler': {
                icon: '‚è∞',
                title: 'Task Scheduler',
                description: 'Schedule task execution',
                color: '#90caf9',
                ports: { inputs: 1, outputs: 1 }
            },
            'condition-router': {
                icon: 'üõ§Ô∏è',
                title: 'Condition Router',
                description: 'Route based on conditions',
                color: '#ffab91',
                ports: { inputs: 1, outputs: 3 }
            },
            'loop-controller': {
                icon: 'üîÑ',
                title: 'Loop Controller',
                description: 'Control loop iterations',
                color: '#f8bbd9',
                ports: { inputs: 1, outputs: 2 }
            },
            'parallel-executor': {
                icon: '‚ö°',
                title: 'Parallel Executor',
                description: 'Execute tasks in parallel',
                color: '#fff59d',
                ports: { inputs: 1, outputs: 3 }
            },

            // Storage
            'cache-manager': {
                icon: 'üè™',
                title: 'Cache Manager',
                description: 'Manage cached data',
                color: '#c5e1a5',
                ports: { inputs: 1, outputs: 1 }
            },
            'state-store': {
                icon: 'üíΩ',
                title: 'State Store',
                description: 'Persistent state storage',
                color: '#d1c4e9',
                ports: { inputs: 1, outputs: 1 }
            },
            'blob-storage': {
                icon: 'üóÉÔ∏è',
                title: 'Blob Storage',
                description: 'Binary large object storage',
                color: '#ffcdd2',
                ports: { inputs: 1, outputs: 1 }
            },
            'search-index': {
                icon: 'üîé',
                title: 'Search Index',
                description: 'Full-text search capabilities',
                color: '#f0f4c3',
                ports: { inputs: 1, outputs: 1 }
            }
        };

        // Initialize the designer
        function initDesigner() {
            createParticles();
            setupEventListeners();
            setupDragAndDrop();
            updateCanvas();
            
            // Add some demo nodes
            setTimeout(() => {
                addDemoNodes();
            }, 1000);
            
            console.log('üöÄ Quantum CSP Visual Designer initialized');
        }

        // Create floating particles
        function createParticles() {
            const container = document.getElementById('particles');
            const particleCount = 50;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 20 + 's';
                particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                container.appendChild(particle);
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            const canvas = document.getElementById('canvas');
            
            // Canvas events
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('wheel', handleZoom);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            
            // Tool selection
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => selectTool(btn.dataset.tool));
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);
            
            // Property inputs
            document.getElementById('grid-size').addEventListener('input', updateGridSize);
        }

        // Setup drag and drop
        function setupDragAndDrop() {
            const canvas = document.getElementById('canvas');
            
            // Component palette drag events
            document.querySelectorAll('.component-item').forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
            });
            
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('drop', handleDrop);
        }

        // Handle component drag start
        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', e.currentTarget.dataset.type);
            e.dataTransfer.effectAllowed = 'copy';
        }

        // Handle drag over canvas
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        // Handle drop on canvas
        function handleDrop(e) {
            e.preventDefault();
            const componentType = e.dataTransfer.getData('text/plain');
            const rect = e.currentTarget.getBoundingClientRect();
            
            const x = (e.clientX - rect.left - panOffset.x) / zoomLevel;
            const y = (e.clientY - rect.top - panOffset.y) / zoomLevel;
            
            if (canvasSettings.snapToGrid) {
                const gridSize = canvasSettings.gridSize;
                x = Math.round(x / gridSize) * gridSize;
                y = Math.round(y / gridSize) * gridSize;
            }
            
            createNode(componentType, x, y);
        }

        // Create a new node
        function createNode(type, x, y) {
            const template = componentTemplates[type] || componentTemplates['atomic'];
            const nodeId = `node_${++nodeCounter}`;
            
            const node = {
                id: nodeId,
                type: type,
                x: x,
                y: y,
                template: template,
                properties: {
                    title: template.title,
                    description: template.description,
                    enabled: true
                }
            };
            
            nodes.push(node);
            renderNode(node);
            
            // Add to selection if in select mode
            if (currentTool === 'select') {
                selectNode(nodeId);
            }
            
            updateMetrics();
            return node;
        }

        // Render a node on the canvas
        function renderNode(node) {
            const canvas = document.getElementById('canvas');
            const nodeEl = document.createElement('div');
            
            nodeEl.className = 'canvas-node fade-in';
            nodeEl.id = node.id;
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
            nodeEl.style.borderColor = node.template.color;
            
            if (node.type.startsWith('ai-')) {
                nodeEl.classList.add('ai-enhanced');
            }
            
            nodeEl.innerHTML = `
                <div class="node-header">
                    <div class="node-type">${node.template.icon}</div>
                    <div class="node-menu">‚ãÆ</div>
                </div>
                <div class="node-title">${node.properties.title}</div>
                <div class="node-description">${node.properties.description}</div>
                <div class="node-status"></div>
                <div class="connection-port input" data-port="input"></div>
                <div class="connection-port output" data-port="output"></div>
            `;
            
            // Make draggable
            makeNodeDraggable(nodeEl);
            
            // Add click handler
            nodeEl.addEventListener('click', (e) => {
                e.stopPropagation();
                if (currentTool === 'select') {
                    selectNode(node.id);
                } else if (currentTool === 'connect') {
                    handleConnection(node.id);
                }
            });
            
            canvas.appendChild(nodeEl);
        }

        // Make node draggable
        function makeNodeDraggable(nodeEl) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            nodeEl.addEventListener('mousedown', (e) => {
                if (currentTool !== 'select' && currentTool !== 'move') return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = parseInt(nodeEl.style.left);
                initialY = parseInt(nodeEl.style.top);
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                let newX = initialX + (e.clientX - startX) / zoomLevel;
                let newY = initialY + (e.clientY - startY) / zoomLevel;
                
                if (canvasSettings.snapToGrid) {
                    const gridSize = canvasSettings.gridSize;
                    newX = Math.round(newX / gridSize) * gridSize;
                    newY = Math.round(newY / gridSize) * gridSize;
                }
                
                nodeEl.style.left = newX + 'px';
                nodeEl.style.top = newY + 'px';
                
                // Update node data
                const node = nodes.find(n => n.id === nodeEl.id);
                if (node) {
                    node.x = newX;
                    node.y = newY;
                }
                
                updateConnections();
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // Handle node selection
        function selectNode(nodeId) {
            // Clear previous selection
            selectedNodes.clear();
            document.querySelectorAll('.canvas-node').forEach(n => {
                n.classList.remove('selected');
            });
            
            // Select new node
            selectedNodes.add(nodeId);
            document.getElementById(nodeId).classList.add('selected');
            
            // Update properties panel
            updatePropertiesPanel(nodeId);
        }

        // Update properties panel
        function updatePropertiesPanel(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            const selectionInfo = document.getElementById('selection-info');
            selectionInfo.innerHTML = `
                <div class="property-field">
                    <label class="property-label">Node ID</label>
                    <input type="text" class="property-input" value="${node.id}" readonly>
                </div>
                <div class="property-field">
                    <label class="property-label">Type</label>
                    <input type="text" class="property-input" value="${node.type}" readonly>
                </div>
                <div class="property-field">
                    <label class="property-label">Title</label>
                    <input type="text" class="property-input" value="${node.properties.title}" 
                           onchange="updateNodeProperty('${nodeId}', 'title', this.value)">
                </div>
                <div class="property-field">
                    <label class="property-label">Description</label>
                    <textarea class="property-input" rows="3" 
                              onchange="updateNodeProperty('${nodeId}', 'description', this.value)">${node.properties.description}</textarea>
                </div>
                <div class="property-field">
                    <label class="property-label">Position</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="number" class="property-input" value="${Math.round(node.x)}" 
                               onchange="updateNodePosition('${nodeId}', 'x', this.value)" style="width: 50%;">
                        <input type="number" class="property-input" value="${Math.round(node.y)}" 
                               onchange="updateNodePosition('${nodeId}', 'y', this.value)" style="width: 50%;">
                    </div>
                </div>
                <div class="property-field">
                    <div class="property-toggle" onclick="toggleNodeProperty('${nodeId}', 'enabled')">
                        <div class="toggle-switch ${node.properties.enabled ? 'active' : ''}" id="enabled-toggle-${nodeId}">
                            <div class="toggle-handle"></div>
                        </div>
                        <span>Enabled</span>
                    </div>
                </div>
            `;
        }

        // Update node property
        function updateNodeProperty(nodeId, property, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            node.properties[property] = value;
            
            // Update visual representation
            const nodeEl = document.getElementById(nodeId);
            if (property === 'title') {
                nodeEl.querySelector('.node-title').textContent = value;
            } else if (property === 'description') {
                nodeEl.querySelector('.node-description').textContent = value;
            }
        }

        // Update node position
        function updateNodePosition(nodeId, axis, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            const numValue = parseInt(value);
            node[axis] = numValue;
            
            const nodeEl = document.getElementById(nodeId);
            nodeEl.style[axis === 'x' ? 'left' : 'top'] = numValue + 'px';
            
            updateConnections();
        }

        // Toggle node property
        function toggleNodeProperty(nodeId, property) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            node.properties[property] = !node.properties[property];
            
            const toggle = document.getElementById(`${property}-toggle-${nodeId}`);
            toggle.classList.toggle('active');
        }

        // Tool selection
        function selectTool(tool) {
            currentTool = tool;
            
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            // Update cursor
            const canvas = document.getElementById('canvas');
            const cursors = {
                select: 'default',
                connect: 'crosshair',
                move: 'move'
            };
            canvas.style.cursor = cursors[tool] || 'default';
        }

        // Handle connection
        function handleConnection(nodeId) {
            if (!isConnecting) {
                connectionStart = nodeId;
                isConnecting = true;
                document.getElementById(nodeId).style.boxShadow = '0 0 20px var(--secondary-glow)';
            } else {
                if (connectionStart !== nodeId) {
                    createConnection(connectionStart, nodeId);
                }
                
                // Reset connection state
                isConnecting = false;
                document.getElementById(connectionStart).style.boxShadow = '';
                connectionStart = null;
            }
        }

        // Create connection
        function createConnection(fromId, toId) {
            const connection = {
                id: `conn_${connections.length + 1}`,
                from: fromId,
                to: toId,
                type: 'data'
            };
            
            connections.push(connection);
            updateConnections();
            updateMetrics();
        }

        // Update connections visual
        function updateConnections() {
            const svg = document.getElementById('connections-svg');
            svg.innerHTML = '';
            
            connections.forEach(conn => {
                const fromNode = document.getElementById(conn.from);
                const toNode = document.getElementById(conn.to);
                
                if (!fromNode || !toNode) return;
                
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                
                const fromX = fromRect.right - canvasRect.left;
                const fromY = fromRect.top + fromRect.height / 2 - canvasRect.top;
                const toX = toRect.left - canvasRect.left;
                const toY = toRect.top + toRect.height / 2 - canvasRect.top;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const controlOffset = Math.abs(toX - fromX) * 0.5;
                
                const d = `M ${fromX} ${fromY} C ${fromX + controlOffset} ${fromY}, ${toX - controlOffset} ${toY}, ${toX} ${toY}`;
                
                path.setAttribute('d', d);
                path.setAttribute('class', 'connection-path');
                path.setAttribute('data-connection', conn.id);
                
                svg.appendChild(path);
            });
        }

        // Canvas interaction handlers
        function handleCanvasClick(e) {
            if (e.target === e.currentTarget) {
                // Clicked on empty canvas
                selectedNodes.clear();
                document.querySelectorAll('.canvas-node').forEach(n => {
                    n.classList.remove('selected');
                });
                updatePropertiesPanel(null);
            }
        }

        function handleMouseDown(e) {
            if (e.target === e.currentTarget && currentTool === 'move') {
                isDragging = true;
                dragStart = { x: e.clientX, y: e.clientY };
            }
        }

        function handleMouseMove(e) {
            if (isDragging && currentTool === 'move') {
                const deltaX = e.clientX - dragStart.x;
                const deltaY = e.clientY - dragStart.y;
                
                panOffset.x += deltaX;
                panOffset.y += deltaY;
                
                updateCanvasTransform();
                
                dragStart = { x: e.clientX, y: e.clientY };
            }
        }

        function handleMouseUp() {
            isDragging = false;
        }

        function handleZoom(e) {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoomLevel = Math.max(0.1, Math.min(3, zoomLevel * delta));
            
            updateCanvasTransform();
        }

        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `scale(${zoomLevel}) translate(${panOffset.x}px, ${panOffset.y}px)`;
        }

        // Zoom controls
        function zoomIn() {
            zoomLevel = Math.min(3, zoomLevel * 1.2);
            updateCanvasTransform();
        }

        function zoomOut() {
            zoomLevel = Math.max(0.1, zoomLevel * 0.8);
            updateCanvasTransform();
        }

        function resetZoom() {
            zoomLevel = 1;
            panOffset = { x: 0, y: 0 };
            updateCanvasTransform();
        }

        // Canvas settings
        function updateGridSize() {
            const gridSize = document.getElementById('grid-size').value;
            canvasSettings.gridSize = parseInt(gridSize);
            updateCanvas();
        }

        function toggleGrid() {
            canvasSettings.showGrid = !canvasSettings.showGrid;
            const toggle = document.getElementById('grid-toggle');
            toggle.classList.toggle('active');
            updateCanvas();
        }

        function toggleSnapToGrid() {
            canvasSettings.snapToGrid = !canvasSettings.snapToGrid;
            const toggle = document.getElementById('snap-toggle');
            toggle.classList.toggle('active');
        }

        function updateCanvas() {
            const canvas = document.getElementById('canvas');
            
            if (canvasSettings.showGrid) {
                const gridSize = canvasSettings.gridSize;
                canvas.style.backgroundImage = `
                    radial-gradient(circle at ${gridSize}px ${gridSize}px, rgba(0, 255, 136, 0.1) 1px, transparent 1px)
                `;
                canvas.style.backgroundSize = `${gridSize}px ${gridSize}px`;
            } else {
                canvas.style.backgroundImage = 'none';
            }
        }

        // Auto layout
        function autoLayout() {
            if (nodes.length === 0) return;
            
            const centerX = 400;
            const centerY = 300;
            const radius = 200;
            
            nodes.forEach((node, index) => {
                const angle = (index / nodes.length) * 2 * Math.PI;
                node.x = centerX + Math.cos(angle) * radius;
                node.y = centerY + Math.sin(angle) * radius;
                
                const nodeEl = document.getElementById(node.id);
                nodeEl.style.left = node.x + 'px';
                nodeEl.style.top = node.y + 'px';
            });
            
            updateConnections();
        }

        // Clear canvas
        function clearCanvas() {
            if (confirm('Are you sure you want to clear the canvas?')) {
                nodes = [];
                connections = [];
                selectedNodes.clear();
                
                document.getElementById('canvas').querySelectorAll('.canvas-node').forEach(node => {
                    node.remove();
                });
                
                updateConnections();
                updateMetrics();
                updatePropertiesPanel(null);
            }
        }

        // Keyboard shortcuts
        function handleKeyDown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 's':
                        e.preventDefault();
                        saveDesign();
                        break;
                    case 'z':
                        e.preventDefault();
                        // Undo functionality
                        break;
                    case 'c':
                        e.preventDefault();
                        // Copy selected nodes
                        break;
                    case 'v':
                        e.preventDefault();
                        // Paste nodes
                        break;
                }
            } else {
                switch (e.key) {
                    case 'Delete':
                        deleteSelected();
                        break;
                    case 'Escape':
                        if (isConnecting) {
                            isConnecting = false;
                            if (connectionStart) {
                                document.getElementById(connectionStart).style.boxShadow = '';
                                connectionStart = null;
                            }
                        }
                        break;
                }
            }
        }

        // Delete selected nodes
        function deleteSelected() {
            selectedNodes.forEach(nodeId => {
                // Remove node
                nodes = nodes.filter(n => n.id !== nodeId);
                document.getElementById(nodeId).remove();
                
                // Remove connections
                connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);
            });
            
            selectedNodes.clear();
            updateConnections();
            updateMetrics();
            updatePropertiesPanel(null);
        }

        // AI functions
        function applySuggestion(type) {
            switch (type) {
                case 'optimize':
                    optimizeNetwork();
                    break;
                case 'validate':
                    securityReview();
                    break;
                case 'generate':
                    addMonitoring();
                    break;
                case 'ml-enhance':
                    enhanceWithML();
                    break;
            }
        }

        function optimizeNetwork() {
            console.log('ü§ñ Optimizing network with caching and load balancing...');
            
            // Add cache manager if not present
            const hasCache = nodes.some(n => n.type === 'cache-manager');
            if (!hasCache) {
                createNode('cache-manager', 500, 400);
            }
            
            // Add rate limiter for load management
            const hasRateLimit = nodes.some(n => n.type === 'rate-limiter');
            if (!hasRateLimit) {
                createNode('rate-limiter', 300, 200);
            }
            
            autoLayout();
            
            setTimeout(() => {
                alert('‚ú® Network optimized! Added caching and rate limiting for 35% better performance');
            }, 2000);
        }

        function securityReview() {
            console.log('üîê Performing security review and adding protection layers...');
            
            // Add auth gateway if not present
            const hasAuth = nodes.some(n => n.type === 'auth-gateway');
            if (!hasAuth) {
                createNode('auth-gateway', 200, 100);
            }
            
            // Add encryption node
            const hasEncryption = nodes.some(n => n.type === 'encryption-node');
            if (!hasEncryption) {
                createNode('encryption-node', 400, 300);
            }
            
            // Add validator
            const hasValidator = nodes.some(n => n.type === 'validator');
            if (!hasValidator) {
                createNode('validator', 600, 200);
            }
            
            setTimeout(() => {
                alert('üõ°Ô∏è Security enhanced! Added authentication, encryption, and input validation');
            }, 1500);
        }

        function addMonitoring() {
            console.log('üìä Adding comprehensive monitoring infrastructure...');
            
            // Add health monitor
            const hasHealth = nodes.some(n => n.type === 'health-checker');
            if (!hasHealth) {
                createNode('health-checker', 150, 450);
            }
            
            // Add metrics collector
            const hasMetrics = nodes.some(n => n.type === 'metrics-collector');
            if (!hasMetrics) {
                createNode('metrics-collector', 350, 450);
            }
            
            // Add logger
            const hasLogger = nodes.some(n => n.type === 'logger');
            if (!hasLogger) {
                createNode('logger', 550, 450);
            }
            
            setTimeout(() => {
                alert('üìà Monitoring added! Health checks, metrics, and logging now active');
            }, 1500);
        }

        function enhanceWithML() {
            console.log('üß† Enhancing system with machine learning capabilities...');
            
            // Add neural network
            const hasNeural = nodes.some(n => n.type === 'neural-network');
            if (!hasNeural) {
                createNode('neural-network', 300, 350);
            }
            
            // Add pattern matcher
            const hasPattern = nodes.some(n => n.type === 'pattern-matcher');
            if (!hasPattern) {
                createNode('pattern-matcher', 500, 350);
            }
            
            // Add ML pipeline
            const hasPipeline = nodes.some(n => n.type === 'ml-pipeline');
            if (!hasPipeline) {
                createNode('ml-pipeline', 400, 250);
            }
            
            setTimeout(() => {
                alert('üöÄ ML enhancement complete! Added neural networks, pattern matching, and ML pipelines');
            }, 2000);
        }

        function generateCode() {
            if (nodes.length === 0) {
                alert('Add some components first!');
                return;
            }
            
            console.log('ü§ñ Generating CSP implementation code...');
            
            // Generate basic CSP code structure
            let code = `// Generated CSP Implementation\n`;
            code += `import { AdvancedCSPEngine, Process, Channel } from './csp-core';\n\n`;
            code += `const engine = new AdvancedCSPEngine();\n\n`;
            
            // Add processes
            nodes.forEach(node => {
                code += `// ${node.properties.title}\n`;
                code += `const ${node.id} = engine.createProcess('${node.type}', {\n`;
                code += `  name: '${node.properties.title}',\n`;
                code += `  description: '${node.properties.description}',\n`;
                code += `  enabled: ${node.properties.enabled}\n`;
                code += `});\n\n`;
            });
            
            // Add connections
            connections.forEach(conn => {
                code += `engine.connect(${conn.from}, ${conn.to});\n`;
            });
            
            code += `\n// Start the CSP system\nengine.start();\n`;
            
            // Show in properties panel
            const propertiesPanel = document.getElementById('properties-panel');
            propertiesPanel.innerHTML += `
                <div class="property-section">
                    <div class="property-section-title">üîß Generated Code</div>
                    <div class="code-preview">${code}</div>
                </div>
            `;
            
            console.log('Generated code:', code);
        }

        function analyzeWithAI() {
            console.log('üß† Performing deep AI analysis...');
            
            setTimeout(() => {
                const insights = [
                    'Detected high-throughput data flow pattern - consider adding stream processors',
                    'Security vulnerability: Missing encryption between AI agents',
                    'Performance bottleneck detected in reasoning coordinator - add parallel executors',
                    'Memory usage optimization: Implement smart caching strategy',
                    'ML pipeline efficiency: Add pattern matchers for better preprocessing',
                    'Monitoring gaps: Need health checkers for critical components',
                    'Authentication layer missing - recommend auth gateway implementation',
                    'Data transformation overhead detected - optimize with dedicated transformers',
                    'Potential deadlock in workflow - add condition routers for better control',
                    'Neural network placement optimal for AI-to-AI communication efficiency'
                ];
                
                const randomInsight = insights[Math.floor(Math.random() * insights.length)];
                alert(`üß† AI Analysis Complete:\n\n${randomInsight}\n\nRecommendation: Check AI suggestions panel for automated fixes.`);
            }, 3000);
        }

        // Export and execution
        function exportDesign() {
            const design = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                nodes: nodes,
                connections: connections,
                settings: canvasSettings
            };
            
            const dataStr = JSON.stringify(design, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'csp_design.json';
            link.click();
            
            console.log('Design exported:', design);
        }

        function runSimulation() {
            if (nodes.length === 0) {
                alert('Add some components first!');
                return;
            }
            
            console.log('‚ñ∂Ô∏è Starting CSP simulation...');
            
            // Simulate execution
            nodes.forEach((node, index) => {
                setTimeout(() => {
                    const nodeEl = document.getElementById(node.id);
                    nodeEl.style.animation = 'pulse 1s ease-in-out';
                    
                    setTimeout(() => {
                        nodeEl.style.animation = '';
                    }, 1000);
                }, index * 500);
            });
            
            setTimeout(() => {
                alert('üöÄ Simulation completed successfully!');
            }, nodes.length * 500 + 1000);
        }

        function openQuickActions() {
            const actions = [
                'Add AI Agent',
                'Add Neural Network',
                'Add Security Gateway',
                'Add Monitoring Suite',
                'Add ML Pipeline',
                'Create Data Flow',
                'Auto Layout',
                'Export Design',
                'Run Simulation'
            ];
            
            const action = prompt('Quick Actions:\n' + actions.map((a, i) => `${i+1}. ${a}`).join('\n'));
            
            switch(parseInt(action)) {
                case 1:
                    createNode('ai-agent', 200, 200);
                    break;
                case 2:
                    createNode('neural-network', 300, 200);
                    break;
                case 3:
                    createNode('auth-gateway', 400, 200);
                    break;
                case 4:
                    addMonitoring();
                    break;
                case 5:
                    createNode('ml-pipeline', 500, 200);
                    break;
                case 6:
                    createDataFlow();
                    break;
                case 7:
                    autoLayout();
                    break;
                case 8:
                    exportDesign();
                    break;
                case 9:
                    runSimulation();
                    break;
            }
        }

        function createDataFlow() {
            // Create a complete data processing flow
            const baseX = 150;
            const baseY = 200;
            const spacing = 200;
            
            const flowNodes = [
                { type: 'api-connector', x: baseX, y: baseY },
                { type: 'validator', x: baseX + spacing, y: baseY },
                { type: 'data-transformer', x: baseX + spacing * 2, y: baseY },
                { type: 'neural-network', x: baseX + spacing * 3, y: baseY },
                { type: 'cache-manager', x: baseX + spacing * 4, y: baseY }
            ];
            
            flowNodes.forEach((node, index) => {
                setTimeout(() => {
                    createNode(node.type, node.x, node.y);
                }, index * 300);
            });
            
            // Connect the flow
            setTimeout(() => {
                for (let i = 0; i < flowNodes.length - 1; i++) {
                    if (nodes.length > i + 1) {
                        createConnection(
                            nodes[nodes.length - flowNodes.length + i].id,
                            nodes[nodes.length - flowNodes.length + i + 1].id
                        );
                    }
                }
            }, flowNodes.length * 300 + 500);
        }

        // Add demo nodes
        function addDemoNodes() {
            const demoNodes = [
                { type: 'ai-agent', x: 150, y: 120 },
                { type: 'llm-processor', x: 400, y: 120 },
                { type: 'reasoning-coordinator', x: 650, y: 120 },
                { type: 'data-transformer', x: 275, y: 240 },
                { type: 'auth-gateway', x: 525, y: 240 },
                { type: 'metrics-collector', x: 150, y: 360 },
                { type: 'neural-network', x: 400, y: 360 },
                { type: 'cache-manager', x: 650, y: 360 }
            ];
            
            demoNodes.forEach((demo, index) => {
                setTimeout(() => {
                    createNode(demo.type, demo.x, demo.y);
                }, index * 200);
            });
            
            // Add demo connections to show data flow
            setTimeout(() => {
                if (nodes.length >= 3) {
                    createConnection(nodes[0].id, nodes[1].id); // AI Agent -> LLM
                    createConnection(nodes[1].id, nodes[2].id); // LLM -> Reasoning Hub
                }
                if (nodes.length >= 5) {
                    createConnection(nodes[0].id, nodes[3].id); // AI Agent -> Transformer
                    createConnection(nodes[3].id, nodes[4].id); // Transformer -> Auth Gateway
                }
                if (nodes.length >= 8) {
                    createConnection(nodes[2].id, nodes[5].id); // Reasoning -> Metrics
                    createConnection(nodes[4].id, nodes[6].id); // Auth -> Neural Network
                    createConnection(nodes[6].id, nodes[7].id); // Neural -> Cache
                }
            }, 2000);
        }

        // Update metrics
        function updateMetrics() {
            // Could update status indicators, performance metrics, etc.
            console.log(`Canvas metrics: ${nodes.length} nodes, ${connections.length} connections`);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initDesigner);
    </script>
</body>
</html>